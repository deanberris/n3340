\section{Example: Generated Type Descriptors}
\label{appendix:example-1}

In this section we take an example type and walk through an example generated
code that compilers are meant to generate for type descriptors. Consider the
following example case:

\begin{verbatim}
  #include <iostreams>
  #include <string>
  #include <runtime>

  struct foo {
    foo() : a_(0), b_(“”) {}
    foo(foo const &) = delete;
    foo(foo &&) = delete;
    foo& operator=(foo) = delete;
    void bar() { /* do nothing */ };
    ~foo() { /* do nothing */ };
   protected:
    int a_;
   private:
    std::string b_;
  };

  int main(int argc, char *argv[]) {
    rich_ptr<foo> f{new foo};
    // The following should print “::foo”.
    std::cout << type_descriptor(f)->name << std::endl;
    delete f.get();
    return 0;
  }
\end{verbatim}

In the above listing we rely on the \verb+type_descriptor+ of the rich pointer f
that mimics the functionality of \verb+std::type_info+. What the compiler
generates then relates to module loading at run-time (in this case is run before
\verb+main+ is called) and the associated type information that users will be
able to access through the \verb+type_descriptor_t+ object resultant to the call
to \verb+type_descriptor+:

\begin{verbatim}
// Type descriptors, generated by compiler and registered through the
// runtime interface. Note that only types that are used through the
// rich pointer syntax will automatically have the type descriptors
// generated for them by the compiler along with the dependent types.
void __register_types() {
  // For convenience...
  typedef type_descriptor_t::method_descriptor_t method_descriptor_t;
  static function_descriptor_t const foo_void_bar {
    “::foo::bar”,  // function name.
    &void_type,  // result type, primitive types defined in <runtime>.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::MEMBER,  // type.
    nullptr,  // member_of, nullptr at this time.
    std::bind(&foo::bar, _1),  // callable
    function, 1st arg is “this”.
  };

  static function_descriptor_t const foo_ctor_0 {
    “::foo::foo”,  // function name.
    nullptr,  // result type, nullptr for constructors.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::CONSTRUCTOR, // type.
    nullptr,  // member_of, nullptr at this time.
    &__constructor<foo>::callable,  // implementation defined.
  };

  static function_descriptor_t const foo_dtor {
    “::foo::~foo”,  // function name.
    nullptr,  // result type, nullptr for destructors.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::DESTRUCTOR,  // type.
    nullptr,  // member_of, nullptr at this time.
    &__destructor<foo>::callable,  // implementation defined.
  };

  static type_descriptor_t const foo_type {
    “::foo”,  // type name.
    {nullptr},  // no bases.
    {
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_ctor_0
      },
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_void_bar
      }, 
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_dtor
      },
      nullptr
    },  // functions.
    {
      {
        “a_”,  // member name.
        &int_type,  // member type, primitives defined in <runtime>.
        field_descriptor_t::PROTECTED,  // access qualifier.
        field_descriptor_t::INSTANCE  // membership qualifer.
      },
      {
        “b_”,  // member name.
        &string_type,  // member type, in compilation of <string>.
        field_descriptor_t::PRIVATE,  // access qualifier.
        field_descriptor_t::INSTANCE  // membership qualifier.
      }
    },  // members.
    sizeof(foo)  // the statically determined size.
  };

  // We then wire up the members.
  const_cast<function_descriptor_t*>(&foo_ctor_0)->member_of = &foo_type;
  const_cast<function_descriptor_t*>(&foo_void_bar)->member_of = &foo_type;
  const_cast<function_descriptor_t*>(&foo_dtor)->member_of = &foo_type;

  // This part is the implementation defined part.
  std::__runtime_register_type_descriptor<foo>(&foo_type);
}
\end{verbatim}

It is intended that the hidden generated function \verb+__register_types+ will
be invoked at module initialization time. Depending on whether dynamically
loaded modules will allow user-defined module intialization/cleanup interfaces
so that users can manually register types and explicitly invalidate types
already registered, the intent is that the compiler-generated descriptors will
still get registered at module scope (internal linkage) and would have to be
explicitly registered at global scope in order to be exported at runtime. It may
be sufficient to use implementation-defined means of marking types as exported
as part of the library interface for shared modules but the intent is to define
a standardized API for this mechanism that works across platforms.

