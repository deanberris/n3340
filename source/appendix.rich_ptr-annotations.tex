\section{Library Implementation: Annotations}
\label{appendix:rich_ptr-annotations}

A few examples of the preprocessor-macro approach to annotating types for type descriptor generation is shown below.

\begin{verbatim}
	template <class T>
	tuple<bool, type_descriptor_t const *>
	register_type() {
	  static_assert(false, “No explicit definition for type provided.”);
	  return make_tuple(false, nullptr);
	}

	// Let’s annotate the type and wrap it in macro’s so that we can
	// programmatically generate the explicit overload for the register_type
	// template function.
	DEFINE_REGISTERED_CLASS(foo)
	  REGISTERED_CONSTRUCTOR(foo()) = default;
	  REGISTERED_DESTRUCTOR(~foo);
	  REGISTERED_MEMBER(void bar());
	  foo(foo &&) = delete;
	  foo(foo const &) = delete;
	  foo& operator=(foo) = delete;
	  PRIVATE_MEMBER(int a_);
	  PRIVATE_MEMBER(string b_);
	END_REGISTERED_CLASS_DEFINITION(foo);

	// We provide explicit overloads and definitions for a given type.
	// This is generated by the macros above right where the class is
	// defined (in END_REGISTERED_CLASS_DEFINITION).
	template <>
	tuple<bool, type_descriptor_t const *>
	register_type<foo>() {
	  static type_descriptor_t const foo_type {
	    /* Defined as shown earlier in the paper. */
	  };
	  // We then duplicate this definition in the rich_ptr<T> static
	  // unique_descriptor.
	  rich_ptr<T>::unique_descriptor = &foo_type;
	  return make_tuple(true, &foo_type);
	}

	// We then call the explicit registrations for types we want to use in
	// main(), or use static initialization of globals to rely on invoking
	// the register_type<...>() function for all registered types.
	int main(int argc, char *argv[]) {
	  register_types<foo>();  // A variadic template function that takes 
	                          // a list of types to actually register at
	                          // the start of main.
	  // as main would normally be.
	  return 0;
	}
\end{verbatim}