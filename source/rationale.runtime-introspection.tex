\subsection{Runtime Introspection}

An example of this use-case is the Qt frameworks'’ QMetaObject type that
describes an object that’s a member of the Qt type hierarchy. A QMetaObject
represents things like type metadata (information associated with types as a
key-value pair accessible at runtime) and methods (descriptions of the methods
supported, accessed through an integer index).

The way types are annotated to provide this information is through the use of
preprocessor macros to generate boilerplate code that registers this information
as a static member of the type. Qt has a rich object system and a means for
runtime dispatch of methods and traversal/inspection of types at runtime that’s
overlaid on top of the normal C++ mechanisms already available. 

Another example of how richer runtime type data can be used to improve current
implementations is how Google Protocol Buffers (ProtoBufs) use type descriptors
to define how a protocol buffer is laid out in memory. This enables the protocol
buffer messages to keep data in a serialized form in memory and support
accessing this data in an efficient manner. The descriptor mechanism allows for
parsing incoming data and determine whether the protocol buffer descriptor
supports the data that’s been received to construct an object of the correct
type.

The down-side for both these approaches are:

\begin{itemize}
\item The information is represented as redundant information generated either
mechanically (in the case of Google ProtoBufs using a proto compiler) or by hand
(in the case of custom Qt types).

\item Both mechanisms are very rigid and cannot trivially be updated
dynamically. The static nature of the information generated does not lend itself
to graceful upgrades while programs using these libraries are running.

\item Most (if not all) of this rich information is largely only useful when
working within the framework of these specific type systems. Mixing and matching
ProtoBuf messages and Qt QObjects for instance so that information can be
rendered in a GUI or streamed/saved to file typically require glue code to take
care of the manual conversion from one type system to another.
\end{itemize}

See an example of how Google ProtoBufs can be implemented to not rely on ad-hoc
reflection generated by the protobuf compiler and just leverage rich pointers
and type descriptors in \autoref{appendix:protobuf-example}.
