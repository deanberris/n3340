\documentclass[10pt,a4paper]{article}
\title{N3340 --- Rich Pointers}
\author{Dean Michael Berris (dberris@google.com) \and Lawrence Crowl
(crowl@google.com) \and Matt Austern (austern@google.com)}
\date{Jan. 10, 2012}
\usepackage{alltt}

% We want to create paragraphs that don't indent the first line.
\setlength{\parindent}{0cm}

% We also want to add a line after each paragraph.
\usepackage{parskip}

% Now we want the document number to appear at the header of the page, while the
% footer will only contain the page number flush to the right. To do this we use
% the fancyhdr package.
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\pagestyle{fancyplain}
\lhead{\fancyplain{}{ISO/IEC JTC1 SC22 WG21 N3340=12-0030 - Rich Pointers; Date:
2012-01-10}}
\rhead{}
\rfoot{\fancyplain{}{\thepage}}
\cfoot{}

% We also want to use listings to identify parts where we're using C++ code.
\usepackage{listings}
\lstset{language=C++}

% Let's use pretty hyperlink references...
\usepackage{hyperref}

\begin{document}
\maketitle
\tableofcontents
\section{Overview}

This paper proposes the definition of a standardized rich pointer and type
descriptor construct in C++ to allow for standardized and efficient runtime
introspection of types and objects. Here we propose the syntax and semantics for
a rich pointer and examples of programming problems addressed by this construct.

\section{Problem Statement}

There are some application areas today where rich runtime information about
objects is crucial.  These application areas include:

\begin{itemize}
\item \textbf{Highly available server applications that have to stay up as a
long running process and enable for dynamic adaptation to changing
requirements.} Upgrades to these applications currently need to be closely
coordinated and tightly controlled, usually requiring that the service be
actually brought down when an upgrade is required. There are solutions that
exist which involve dynamically loaded libraries but changing the design of
already packaged types in the system usually require downtime to rebuild and
relink the binary.

\item \textbf{Applications that embed dynamic programming languages typically
settle for either a static interface to which the embedded dynamic language
runtime, or a pure data interface implementing a (static) protocol between the
embedded environment and the host application.} Usually the dynamic types that
can be generated in these embedded virtual machines are only usable in the
context of these virtual machines limiting the interactions by which these
embedded types interact with the host application.

\item \textbf{Distributed computing systems written in C++ are largely tied to
static interfaces and types because of the limitation of the programming
language.} We currently do not have a standard programmatic way of dynamically
generating types and referring to objects of these types and streaming objects
of these types from one system to another. Current state of the art relies on
code generators, domain specific languages, and even communication frameworks to
achieve remote procedure calling and sharing state across elements in a
distributed system.

\item \textbf{Applications use machine learning and dynamic modeling of
environments through continuous refinement of data structures in memory rely on
the capability to treat code as data, or at least be able to inspect the state
and relationship between types in a hierarchy of types.} The current limitations
of the language force the applications that deal with constantly changing
structures and types is to model them in runtime as merely data, losing much of
the power of the programming language’s runtime facility for efficiently
modeling types and objects in the process.

\item \textbf{Graphical user interfaces typically rely on being able to inspect
in­memory structures to represent graphical elements to be rendered on screen.}
Almost all the sufficiently advanced graphical user interface toolkits now use a
statically­defined and very rigid type system and implement a runtime meta­type
system because the programming language currently does not have a facility of
doing proper rich runtime introspection of types.
\end{itemize}

There are several problems that this paper aims to address. Here are some of
these questions:

\begin{itemize}
\item \emph{How do we find out what the type of an object is at a given memory
location?}  Type erasure allows us to expose a generic API that works well
across module boundaries, but being able to preserve type information across
these module boundaries without having to rebuild and relink binaries is also as
powerful.

\item \emph{How do we print the structure of a dynamic type at runtime?}
Currently there are no ways to do this dynamically without resorting to manual,
static, and expensive checks on types that are members of a statically-known
hierarchy of types. There exists no standard means of knowing the type of a
given object in memory at runtime with the current features of the language,
especially when referred to using either a \verb+void *+ or a base type pointer.

\item \emph{How do we determine the relationship between any two given types at
runtime?} The current way of doing this requires manual checks for whether one
type can be dynamically cast to another, and inferring from the result what the
potential relationship between the types is. There is currently no way of
determining what types a given type is derived from, what type of inheritance
(public, private, protected, virtual, etc.) these relationships are, and whether
a given type is an abstract class or whether it is a final class, etc.

\item \emph{If we were able to create new types at runtime, how do we describe
these types and inspect them?} For applications that rely on live updates for
high availability and remote procedure calling systems, being able to
reconstitute a type dynamically based on data obtained externally via I/O is
crucial. Currently the only way to allow this is to implement a runtime type
system by hand and perform all type inspections by hand, unable to leverage the
rich type system that C++ provides. This is also important in applications where
an embedded just-in-time (JIT) compiler can create new structures
programmatically as well as allowing types generated in embedded runtime
environments to be exported to the host application.
\end{itemize}

\section{Proposed Solution}

The problems raised above point to general dynamic programming utilities called
runtime introspection and reflection. Enabling introspection and reflection at
runtime has traditionally been costly and almost always requires the concept of
a virtual machine for it to be doable. In this paper we describe a mechanism for
enabling introspection and potentially reflection without the need for a
heavyweight virtual machine or runtime to make it possible. The benefits include
but are not limited to: better runtime debugging and instrumentation for
profiling as well as for first-class garbage collection support.

\subsection{Rich Pointers}

The smart pointer idiom has been generally accepted in practice largely for the
utilities afforded to us by these smart pointers. The standard library now
contains three smart pointers: unique\_ptr, shared\_ptr, and weak\_ptr. These
smart pointers encapsulate generic patterns for dealing with memory ownership
and management and makes it transparent to users.

Following the smart pointer idiom this paper proposes a concept called rich
pointers which not only carry the memory location of a given object but also a
reference to an immutable representation of the type of this object (we call
these type descriptors). The proposed syntax for a rich pointer follows the
general style of a pointer but instead of using the * symbol to denote a pointer
we use the percent ``\%'' symbol to do so.

\begin{verbatim}
  struct foo {
      foo() {}
      ~foo() {}
  };

  foo %p = new (std::rich) foo;
\end{verbatim}

For the most part a rich pointer behaves like a normal pointer. Dereferencing
will yield a reference to the object pointed to but you can no longer perform
normal pointer arithmetic. When a rich pointer is assigned to a normal pointer,
the memory location is transferred and the reference to the original type
descriptor is dropped (this is to ensure backward compatibility).

What rich pointers support that would be hard to support with normal pointers is
the notion of preserving type information even across casts even to
\verb+void %+. To illustrate more appropriately:

\begin{verbatim}
  void %q = p;
  foo %r = rich_cast<foo%>(q);
  assert(type_descriptor(q) == type_descriptor(r));
\end{verbatim}

Because p and q point to the same object in memory, getting the type descriptor
of both pointers will yield the same type descriptor. In fact, any object of
type foo in memory when referred to via a rich pointer will have the same type
descriptor.

\subsection{Type Descriptors}

The reason we’re proposing a language feature to support rich pointers as
opposed to a smart pointer implemented in C++ is so that the generation of type
descriptors can be implemented by the compiler (whether an embedded JIT
compiler, or a normal compiler). Type descriptors are maintained by the language
runtime are tied directly to the runtime type information (RTTI) implementation.

To access a type descriptor, we’re introducing a standard function called \\
\verb+type_descriptor+ which returns a pointer to an immutable object
representing that unique type. Please refer to
\autoref{appendix:type-descriptors-appendix} for the complete details of the
structure of this descriptor.

What type descriptors contain is rich type information regarding a specific
type. The idea is, all the types ever referred to via a rich pointer in a
translation unit will expose a type descriptor. This type descriptor is then
considered immutable and attempts to programmatically change an existing type
descriptor invokes undefined behavior.

A compiler will be able to generate these type descriptors and make them
available to the runtime implementation. Please refer to
\autoref{appendix:example-1} for details of the example type descriptors
generated for a simple case.

There are two ways of making the runtime manage descriptors: registration and
invalidation.

When a type descriptor is registered in the runtime, it must not allow the
redefinition of an existing descriptor tied to a specific type. Attempts to
register a different descriptor to an already registered type should fail. This
enables dynamically loaded shared libraries to add new type descriptors to an
existing runtime environment.

Invalidating a type descriptor does two things: invalidates all rich pointers to
objects of the invalidated type -- attempts to dereference the pointers of an
invalidated type will then lead to exceptions that can be handled either by user
code or by a special invalidation handler associated with the type. Invalidation
handlers can be registered using the same mechanism by which new types are
registered. This enables dynamically loaded shared libraries to invalidate types
that it intends to either explicitly stop supporting or upgrade to a newer
version. 

Please refer to \autoref{appendix:type-registration-invalidation} for the
proposed interface for making this happen manually either by explicit
invalidation by module-writers or implicitly by the compiler-generated module
initialization routines.

\section{Rationale}

The current state of the art of dealing at runtime of types involves
manipulating and traversing statically defined type descriptors. These type
descriptors contain information about the types they’re supposed to represent
(members, inheritance hierarchy, etc.) and are encapsulated with the same type
they typically describe. This is useful for determining at runtime for example
how to display certain pieces of information.

\subsection{Runtime Introspection}

An example of this use-case is the Qt frameworks'’ QMetaObject type that
describes an object that’s a member of the Qt type hierarchy. A QMetaObject
represents things like type metadata (information associated with types as a
key-value pair accessible at runtime) and methods (descriptions of the methods
supported, accessed through an integer index).

The way types are annotated to provide this information is through the use of
preprocessor macros to generate boilerplate code that registers this information
as a static member of the type. Qt has a rich object system and a means for
runtime dispatch of methods and traversal/inspection of types at runtime that’s
overlaid on top of the normal C++ mechanisms already available. 

Another example of how richer runtime type data can be used to improve current
implementations is how Google Protocol Buffers (ProtoBufs) use type descriptors
to define how a protocol buffer is laid out in memory. This enables the protocol
buffer messages to keep data in a serialized form in memory and support
accessing this data in an efficient manner. The descriptor mechanism allows for
parsing incoming data and determine whether the protocol buffer descriptor
supports the data that’s been received to construct an object of the correct
type.

The down-side for both these approaches are:

\begin{itemize}
\item The information is represented as redundant information generated either
mechanically (in the case of Google ProtoBufs using a proto compiler) or by hand
(in the case of custom Qt types).

\item Both mechanisms are very rigid and cannot trivially be updated
dynamically. The static nature of the information generated does not lend itself
to graceful upgrades while programs using these libraries are running.

\item Most (if not all) of this rich information is largely only useful when
working within the framework of these specific type systems. Mixing and matching
ProtoBuf messages and Qt QObjects for instance so that information can be
rendered in a GUI or streamed/saved to file typically require glue code to take
care of the manual conversion from one type system to another.
\end{itemize}

See an example of how Google ProtoBufs can be implemented to not rely on ad-hoc
reflection generated by the protobuf compiler and just leverage rich pointers
and type descriptors in \autoref{appendix:protobuf-example}.

\subsection{Fully Dynamic Extension}

For network server applications there have been two major ways of achieving
dynamic upgrades of a running system. The way the Apache Web Server does it as
an example is to define a very strict protocol for how dynamic shared objects
are described and behave -- all extensions are implemented through this system
which also relies on the dynamic linker to resolve symbols when new modules are
loaded into a running system. The other way is done by many games and dynamic
systems is to embed a dynamic language runtime (like Lua) so that the parts that
are meant to be upgraded at runtime can be implemented in a fully dynamic
programming environment that supports this functionality natively without having
to bring the whole application down.

Both these approaches are valid but they have their own trade-offs.

The dynamic module approach relies heavily on external dynamic linking solutions
that have traditionally only been implemented in C and support only a C
application binary interface (ABI). Although it is possible to hide the C++
implementation behind a C interface it limits the integration possibilities
between host applications and dynamic modules. Furthermore this facility is
largely platform dependent and is not standardized across vendor
implementations.

Embedding a dynamic language runtime has the same limitations as typically the
interaction between the host application and the embedded runtime are limited.
The types generated or used in the context of the runtime typically have to be
converted programmatically into something that the host application explicitly
understands. The performance and maintenance costs of systems that do use
embedded runtimes are also non-trivial.

In \autoref{appendix:plugins-example} we show an approach to adding dynamically
registered types as plug-ins to an application.

\appendix
\section{Appendix: Type Descriptor Details}
\label{appendix:type-descriptors-appendix}
The following structure definitions show the details that type descriptors can
contain. Here we describe a means for exposing descriptors for functions
(\verb+function_descriptor_t+), member data (\verb+field_descriptor_t+), and
classes/structs (\verb+type_descriptor_t+).

\begin{alltt}
  struct function\_descriptor\_t \{
    char const *name;  // null terminated function name
    type\_descriptor\_t const *result\_type;
    type\_descriptor\_t const *args[];
    enum \{ NORMAL, VIRTUAL, CONST, VOLATILE,
           CONSTEXPR, STATIC, NAMESPACE \} qualifiers\_t;
    int qualifiers;  // binary OR’ed qualifiers\_t values.
    enum \{ CONSTRUCTOR, DESTRUCTOR, FREE, MEMBER \}
    function\_type\_t;
    function\_type\_t function\_type;
    type\_descriptor\_t *member\_of;  // pointer to enclosing type.
    \emph{unspecified\_type} callable;
  \};
\end{alltt}
\begin{verbatim}
  struct field_descriptor_t {
    char const *name;  // null terminated member name
    type_descriptor_t const *type;
    enum { PRIVATE, PUBLIC, PROTECTED }
    access_qualifiers_t;
    access_qualifiers_t access_qualifier;
    enum { INSTANCE, STATIC }
    membership_qualifiers_t;
    membership_qualifiers_t membership_qualifier;
  };

  struct type_descriptor_t {
    char const * name;  // null terminated type name

    struct inheritance_descriptor_t {
      enum { PRIVATE, PUBLIC, PROTECTED } access_type_t;
      access_type_t access_type;
      enum { FINAL, VIRTUAL } inheritance_type_t;
      inheritance_type_t inheritance_type;
      type_descriptor_t const *base;
    };

    inheritance_descriptor_t *bases[];

    struct method_descriptor_t {
      enum { PRIVATE, PUBLIC, PROTECTED } access_type_t;
      access_type_t access_type;
      enum { NORMAL, FINAL, VIRTUAL } inheritance_type_t;
      inheritance_type_t inheritance_type;
      function_descriptor_t const *type;
    };

    method_descriptor_t *methods[];
    field_descriptor_t *members[];
    size_t size;
  };
\end{verbatim}

The prototypes for the \verb+type_descriptor+ function are given below:

\begin{verbatim}
  template <class T>
  type_descriptor_t const *
  type_descriptor(T%);

  template <class T>
  type_descriptor_t const *
  type_descriptor(T*);

  template <class R, class T...>
  function_descriptor_t const *
  type_descriptor(R(T...) *);  // for function pointers.
\end{verbatim}

\section{Example: Generated Type Descriptors}
\label{appendix:example-1}

In this section we take an example type and walk through an example generated
code that compilers are meant to generate for type descriptors. Consider the
following example case:

\begin{verbatim}
  #include <iostreams>
  #include <string>
  #include <runtime>

  struct foo {
    foo() : a_(0), b_(“”) {}
    foo(foo const &) = delete;
    foo(foo &&) = delete;
    foo& operator=(foo) = delete;
    void bar() { /* do nothing */ };
    ~foo() { /* do nothing */ };
   protected:
    int a_;
   private:
    std::string b_;
  };

  int main(int argc, char *argv[]) {
    foo %f = new(std::rich) foo;
    // The following should print “::foo”.
    std::cout << type_descriptor(f)->name << std::endl;
    delete f;
    return 0;
  }
\end{verbatim}

In the above listing we rely on the \verb+type_descriptor+ of the rich pointer f
that mimics the functionality of \verb+std::type_info+. What the compiler
generates then relates to module loading at run-time (in this case is run before
\verb+main+ is called) and the associated type information that users will be
able to access through the \verb+type_descriptor_t+ object resultant to the call
to \verb+type_descriptor+:

\begin{verbatim}
// Type descriptors, generated by compiler and registered through the
// runtime interface. Note that only types that are used through the
// rich pointer syntax will automatically have the type descriptors
// generated for them by the compiler along with the dependent types.
void __register_types() {
  // For convenience...
  typedef type_descriptor_t::method_descriptor_t method_descriptor_t;
  static function_descriptor_t const foo_void_bar {
    “::foo::bar”,  // function name.
    &void_type,  // result type, primitive types defined in <runtime>.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::MEMBER,  // type.
    nullptr,  // member_of, nullptr at this time.
    std::bind(&foo::bar, _1),  // callable
    function, 1st arg is “this”.
  };

  static function_descriptor_t const foo_ctor_0 {
    “::foo::foo”,  // function name.
    nullptr,  // result type, nullptr for constructors.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::CONSTRUCTOR, // type.
    nullptr,  // member_of, nullptr at this time.
    &__constructor<foo>::callable,  // implementation defined.
  };

  static function_descriptor_t const foo_dtor {
    “::foo::~foo”,  // function name.
    nullptr,  // result type, nullptr for destructors.
    {nullptr},  // no arguments.
    function_descriptor_t::NORMAL,  // qualifiers.
    function_descriptor_t::DESTRUCTOR,  // type.
    nullptr,  // member_of, nullptr at this time.
    &__destructor<foo>::callable,  // implementation defined.
  };

  static type_descriptor_t const foo_type {
    “::foo”,  // type name.
    {nullptr},  // no bases.
    {
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_ctor_0
      },
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_void_bar
      }, 
      {
        method_descriptor_t::PUBLIC,
        method_descriptor_t::NORMAL,
        &foo_dtor
      },
      nullptr
    },  // functions.
    {
      {
        “a_”,  // member name.
        &int_type,  // member type, primitives defined in <runtime>.
        field_descriptor_t::PROTECTED,  // access qualifier.
        field_descriptor_t::INSTANCE  // membership qualifer.
      },
      {
        “b_”,  // member name.
        &string_type,  // member type, in compilation of <string>.
        field_descriptor_t::PRIVATE,  // access qualifier.
        field_descriptor_t::INSTANCE  // membership qualifier.
      }
    },  // members.
    sizeof(foo)  // the statically determined size.
  };

  // We then wire up the members.
  const_cast<function_descriptor_t*>(&foo_ctor_0)->member_of = &foo_type;
  const_cast<function_descriptor_t*>(&foo_void_bar)->member_of = &foo_type;
  const_cast<function_descriptor_t*>(&foo_dtor)->member_of = &foo_type;

  // This part is the implementation defined part.
  std::__runtime_register_type_descriptor<foo>(&foo_type);
}
\end{verbatim}

It is intended that the hidden generated function \verb+__register_types+ will
be invoked at module initialization time. Depending on whether dynamically
loaded modules will allow user-defined module intialization/cleanup interfaces
so that users can manually register types and explicitly invalidate types
already registered, the intent is that the compiler-generated descriptors will
still get registered at module scope (internal linkage) and would have to be
explicitly registered at global scope in order to be exported at runtime. It may
be sufficient to use implementation-defined means of marking types as exported
as part of the library interface for shared modules but the intent is to define
a standardized API for this mechanism that works across platforms.

\section{Type Registration and Invalidation}
\label{appendix:type-registration-invalidation}

There are two functions that are being proposed as standard extensions in the
\verb+<runtime>+ header: \verb+register_type+ and \verb+invalidate_type+.

\verb+register_type+ is meant to be called at module initialization time
depending on how dynamic/shared or static modules are initialized.  The result
is a boolean indicating success and a pointer to the new immutable type
descriptor. This will only return true if the type T is valid and that it has
not been previously registered.

\begin{verbatim}
  // Example usage:
  //     bool ok;
  //     type_descriptor_t const *p;
  //     tie(ok, p) = register_type(new(std::rich) foo);
  //     assert(ok);
  template <class T>
  tuple<bool, type_descriptor_t const *>
  register_type(T%);
\end{verbatim}

\verb+invalidate_type+ is meant to be called at module initialization time
depending on how dynamic/shared or static modules are initialized.
The result contains a boolean indicating success and pointers to the
invalidated type descriptor and new type descriptor. It is important
that this is called at module initialization time when the current
runtime context and module-specific runtime contexts are available.
Calls to \verb+new(std::rich)+ within module scope will always use the
module-specific runtime context. During module initialization, calls
to \verb+type_descriptor(...)+ will always refer to the current runtime
context. If a type is not already registered through
\verb+register_type(...)+ then calling \verb+invalidate_type+ will return the tuple
(\verb+false+, \verb+nullptr+, descriptor to new type).

\begin{verbatim}
  template <class T>
  tuple<bool, type_descriptor_t const *, type_descriptor_t const *>
  invalidate_type(type_descriptor_t const *, T%,
                  function<bool(type_descriptor_t const *, T%&)>);
\end{verbatim}

The following listings show example example usage of the \verb+invalidate_type+
function.

\begin{verbatim}
  bool ok;
  type_descriptor_t const *old_type, *new_type;
  foo %old = nullptr;
  tie(ok, old_type, new_type) =
      invalidate_type(type_descriptor(old), new(std::rich) foo);
  assert(new_type != old_type && ok);
\end{verbatim}

Another case is for ``deregistering'' a type, by simply providing nullptr to the
second argument to \verb+invalidate_type+:

\begin{verbatim}
  tie(ok, old_type, new_type) =
      invalidate_type(type_descriptor(old), nullptr);
  assert(new_type == nullptr && type_invalidated(old) && !ok);
\end{verbatim}

The above is suggested for module cleanup time when types only meant for module
scope should be deregistered and all rich pointers for these types should be
invalidated.

The third argument to \verb+invalidate_type+ is the invalidation handler
function. This function is called when a rich pointer of an invalidated type is
dereferenced. It is passed the old type descriptor and a reference to the
invalidated rich pointer.  The invalidation handler should return true if it
should allow the application to continue execution and false to force a call to
\verb+std::abort+. The default handler throws an \verb+invalidated_ptr+
exception which contains the invalidated pointer and a pointer to the old type
descriptor.

A convenience function for explicitly checking whether the type of a given
pointer has been invalidated.

\begin{verbatim}
  bool type_invalidated(void%);
\end{verbatim}

There are only ever at most two versions of a type descriptor for any given
registered type.

\section{Google Protocol Buffers Generic Serialization}
\label{appendix:protobuf-example}
An example of how a Google Protocol Buffer (protobuf) serialization mechanism
would work is shown below as a function that takes any protobuf object and
serializes it to an output stream.

\begin{verbatim}
// We want to ensure that the pointer we’re going to take does
// point to an object statically derived from proto::Message. For
// this we leverage the normal C++ static rules for inheritance
// and polymorphism.
namespace proto {
  bool serialize(Message %m, std::ostream &os) {
    // In here we can then inspect the type associated with the pointer m
    // reflecting the runtime representation.
    type_descriptor_t const *type = type_descriptor(m),
                            *msg_type = type_descriptor<Message>(nullptr);

    // We then traverse the members of the protocol buffer and perform a generic
    // lookup of the data so we can encode properly into the output stream.
    std::string buffer;
    for (field_descriptor_t const *field : type->members) {
      if (field == nullptr)
        break;
      if (!m->get_member(field->name, &buffer))
        return false;
      os.write(s.data(), s.size());
    }
    return true;
  }
}
\end{verbatim}

For exposition and completeness, we provide an example implementation of
\verb+proto::Message+’s \verb+get_member+ function and enclosing scope using
rich pointers and introspection functionality:

\begin{verbatim}
namespace proto {
  class Message {
    char *buffer_;  // dynamically initialized by derived classes
    static std::map<std::string, type_descriptor_t const *> registry;

   protected:
    explicit Message(size_t derived_size)
    : buffer_(new (std::nothrow) char[derived_size]) {}

   public:
    virtual bool get_member(std::string const &name, std::string *buffer) {
      type_descriptor_t const *type =
          registry[type_descriptor(rich_cast<Message%>(this))->name];
      bool ok = false;
      size_t offset = 0;
      field_descriptor_t const * field = nullptr;
      tie(ok, offset, field) = get_offset(name, type->members);
      if (!ok) return false;
      size_t size = field->type->size;
      buffer->assign(buffer_ + offset, buffer_ + size);
      return ok;
    }

    virtual ~Message() {
      delete [] buffer_;
    }
  };
}
\end{verbatim}

\section{Dynamic Plugins Example}
\label{appendix:plugins-example}

Here we show one approach to adding dynamically registered types as plug-ins to
a hypothetical server using rich pointers:

\begin{verbatim}
// We want to have a global registry of handler objects mapped to URLs.
static map<string, pair<void%, function<void<string>>>> handlers;

// Then we define a way for a new module to register completely new
// objects at runtime:
bool register_handler(std::string const &url,
                      void %handler,
                      bool replace) {
  // Here we can determine whether the object being registered as a
  // handler supports the required API (at runtime!)
  type_descriptor_t const *type = type_descriptor(handler);
  if (type == nullptr) return false;

  bool compliant = true;
  type_descriptor_t const *string_type =
      type_descriptor(rich_cast<std::string%>(nullptr));

  function<void(string)> f;
  for (method_descriptor_t const *method : type->methods) {
    if (method == nullptr) break;
    compliant = compliant || (
        equals(method->type->name, “get”)
        && method->access_type == method_descriptor_t::PUBLIC
        && length(method->type->args) == 2
        && method->type->result_type == nullptr
        && method->type->args[1] == string_type);
    if (compliant && !f.get()) f = bind(method->type->callable, f, _1);
  }
  if (!compliant) return false;
  if (!replace && handlers.find(url) != handlers.end()) return false;
  handlers[url] = make_pair(handler, f);
  return true;
}

// When we’re ready to handle a URL, we do the following:
bool handle_url(std::string const &url, std::string const &request) {
  auto it = handlers.find(url);
  if (it != handlers.end()) {
    try {
      (*it)(request);
    } catch (...) {
      return false;
    }
    return true;
  }
  return false;
}
\end{verbatim}

\end{document}
