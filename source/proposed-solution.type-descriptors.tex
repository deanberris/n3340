\subsection{Type Descriptors}

The metadata about an object's structure can only be generated by the compiler
and therefore compiler assistance is required to support automatically generated
type descriptors. These type descriptors can be inspected statically and
dynamically. The runtime equivalent of the type descriptors are maintained by
the language runtime and are tied directly to the runtime type information
(RTTI) implementation.

To access a type descriptor at runtime, weâ€™re introducing a standard function
called \verb+type_descriptor+ which returns a pointer to an immutable object
representing that unique type. Please refer to
\autoref{appendix:type-descriptors-appendix} for the complete details of the
structure of this descriptor. To access a type descriptor at compile-time we're
introducing a trait called \verb+metadata+. Please refer to
\autoref{appendix:metadata-appendix} for the complete details of the structure
of this trait and other related traits.

What type descriptors contain is rich type information regarding a specific
type. The idea is, all the types ever referred to via a rich pointer in a
translation unit will expose a type descriptor. This type descriptor is then
considered immutable and attempts to programmatically change an existing type
descriptor invokes undefined behavior.

A compiler will be able to generate these type descriptors and make them
available to the runtime implementation. Please refer to
\autoref{appendix:example-1} for details of the example type descriptors
generated for a simple case and \autoref{appendix:example-2} for the static
descriptors examples.

There are two ways of making the runtime manage descriptors: registration and
invalidation.

When a type descriptor is registered in the runtime, it must not allow the
redefinition of an existing descriptor tied to a specific type. Attempts to
register a different descriptor to an already registered type should fail. This
enables dynamically loaded shared libraries to add new type descriptors to an
existing runtime environment.

Invalidating a type descriptor does two things: invalidates all rich pointers to
objects of the invalidated type -- attempts to dereference the pointers of an
invalidated type will then lead to exceptions that can be handled either by user
code or by a special invalidation handler associated with the type. Invalidation
handlers can be registered using the same mechanism by which new types are
registered. This enables dynamically loaded shared libraries to invalidate types
that it intends to either explicitly stop supporting or upgrade to a newer
version.

Please refer to \autoref{appendix:type-registration-invalidation} for the
proposed interface for making this happen manually either by explicit
invalidation by module writers or implicitly by the compiler-generated module
initialization routines.
