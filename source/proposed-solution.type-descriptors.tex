\subsection{Type Descriptors}

The reason we’re proposing a language feature to support rich pointers as
opposed to a smart pointer implemented in C++ is so that the generation of type
descriptors can be implemented by the compiler (whether an embedded JIT
compiler, or a normal compiler). Type descriptors are maintained by the language
runtime are tied directly to the runtime type information (RTTI) implementation.

To access a type descriptor, we’re introducing a standard function called \\
\verb+type_descriptor+ which returns a pointer to an immutable object
representing that unique type. Please refer to
\autoref{appendix:type-descriptors-appendix} for the complete details of the
structure of this descriptor.

What type descriptors contain is rich type information regarding a specific
type. The idea is, all the types ever referred to via a rich pointer in a
translation unit will expose a type descriptor. This type descriptor is then
considered immutable and attempts to programmatically change an existing type
descriptor invokes undefined behavior.

A compiler will be able to generate these type descriptors and make them
available to the runtime implementation. Please refer to
\autoref{appendix:example-1} for details of the example type descriptors
generated for a simple case.

There are two ways of making the runtime manage descriptors: registration and
invalidation.

When a type descriptor is registered in the runtime, it must not allow the
redefinition of an existing descriptor tied to a specific type. Attempts to
register a different descriptor to an already registered type should fail. This
enables dynamically loaded shared libraries to add new type descriptors to an
existing runtime environment.

Invalidating a type descriptor does two things: invalidates all rich pointers to
objects of the invalidated type -- attempts to dereference the pointers of an
invalidated type will then lead to exceptions that can be handled either by user
code or by a special invalidation handler associated with the type. Invalidation
handlers can be registered using the same mechanism by which new types are
registered. This enables dynamically loaded shared libraries to invalidate types
that it intends to either explicitly stop supporting or upgrade to a newer
version. 

Please refer to \autoref{appendix:type-registration-invalidation} for the
proposed interface for making this happen manually either by explicit
invalidation by module-writers or implicitly by the compiler-generated module
initialization routines.

